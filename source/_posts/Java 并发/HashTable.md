1. 根据jdk类注释中可以得到的一些信息

   - HashTable是线程安全的，但是如果不要求线程安全推荐使用HashMap来代替HashTable，

     要求线程安全那么就使用HashTable

   - 要求键值不能为空

   - 如果会用较多的元素使用，那么最好设置足够的容量来减少添加元素时扩容的浪费的时间

   - 关于modCount：在HashTable被创建完成后，除了使用iterator自己的remove方法，其他任何对于它结构性改变的方法都会抛出ConcurrentModificationException；因此在面对同步更改的情况下iterator能够失败得快而干净。但是这并不能对于非同步的同时更改带来硬性保证不会出现问题。

     我们在iterator中看到这个也就明白了，在得到自己的遍历器的时候就会自己期望的更改次数值为当前的已经的更改次数值。

     ```java
     expectedModCount = modCount;
     ```

     当一个对象得到它的遍历器的时候也就是准备遍历它的所有元素，那么在这个遍历过程中我也就不想其中有元素会有所改变，所以在这个时候如果我们通过直接调用容器的删除添加元素等方法就会造成。

     

2. HashTable处理哈希冲突的方法也是使用了链式存储法

3. 其实其他的大多就跟HashMap一样，最大不一样也就是进行了共享资源的同步。

   

   

   

   

   

   

   

   

   

   

   

   

   

   