### 关于java8 实战

#### 并行数据处理与性能

1. 在使用前必须确保，需要并行化的数据没有数据相关性，也就是说，多个并行流之间不存在对共享数据进行操作
2. 留意装箱和拆箱，这个比较消耗性能
3. 与流中元素顺序相关的操作比顺序无关的操作性能差
4. 设N是要处理的元素的总数，Q是一个元素通过 流水线的大致处理成本，则N*Q就是这个对成本的一个粗略的定性估计。Q值较高就意味 着使用并行流时性能好的可能性比较大。 
5. 少量的数据不用并行流
6. 要考虑流背后的数据结构是否易于分解 ；根据ArrayList和LinkedList的拆分器我们就可以看得出来，ArrayList的拆分直接把自己拥有的元素数组赋值给拆分器的数组元素，然后对这个数组元素进行拆分；但是LInkedList是把自己的引用传给拆分器的collection属性，拆分的时候是通过遍历添加进新建的数组，然后又传给新建的数组拆分器

#### 关于默认方法

- 怎么使用默认方法：

  1. 由于API	版本的迭代，我们发现实现一个接口缺少了某些必要的方法；但是如果直接向接口中添加方法就会发现没有实现这个方法而发生编译错误；但是使用默认方法，我们就可以避免这个问题，接口提供了一个默认实现，用户可以覆盖这个方法而有自己的实现。

  2. 实现一个接口，但是并不是所有实现的类都需要其中的所有方法，以前我们的解决方式是实现一个空方法，有了默认方法，我们就可以在接口中以以下方式实现这个方法

     ```java
     default void method(){
         throw new UnsupportedOperationException();
     }
     ```

  3. 行为的多继承

     - 解决多实现冲突的规则：
       1. 类或父类中声明的方法优先级高于任何声明为默认方法的优先级(也就是说默认方法如果被覆盖了就以被覆盖的方法为准)
       2. 如果无法根据第一条进行判断，那么子接口的优先级更高：函数签名相同时，优先选择拥有最具体实现的默认方法的接口，即如果B继承了A，那么B就比A具体
          1. 最后，如果还无法判断，继承了多个接口的类必须通过显示覆盖和调用期望方法