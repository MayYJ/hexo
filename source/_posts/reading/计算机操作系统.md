### 存储器管理

#### 存储器的层次结构

##### 多级存储器结构

- 操作系统的存储管理，负责对可执行存储器的分配、回收以及提供在存储层次间数据移动的管理机制
- 主要分三层：CPU寄存器（寄存器），主存（高速缓存、主存、磁盘缓存）、辅存（磁盘、可移动介质）

####  程序的装入和链接

##### 程序的装入

1. 绝对装入方式：程序员需要知道程序将驻留在什么位置
2. 可重定位装入方式：程序指定程序驻留内存的相对位置
3. 动态运行时装入方式：并不立即把装入模块中的相对无位置转换为绝对位置，而是把这种地址转换推迟到程序真正要执行时才运行

##### 程序的链接

1. 静态链接方式：在程序运行前，先将各目标模块及它们所需的库函数，链接成一个完整的装配模块，以后不再拆开
2. 装入时动态链接：装入一个模块时，若发生一个外部模块调用事件，将引起装入程序去找对应的外部目标模块，并将它装入内存。
3. 运行时动态链接：在程序运行时，将目标模块装入内存

#### 连续分配方式

##### 单一连续分配

##### 固定分区分配

- 划分分区方法：将内存的用户空间划分为若干个固定大小的分区（有分区大小相等和不相等两种方式）
- 内存分配：使用一张分区使用表来进行分区的使用

##### 动态分区分配

- 分配方式：根据进程的需要，动态的为之分配内存空间

- 分区分配中的数据结构：

  1. 空闲分区表
  2. 空闲分区链

- 分区分配算法

  1. 首次适应算法

     - 定义：空闲分区链以地址递增的次序链接，在分配内存时从链首开始顺序查找

     - 缺点：倾向于分配低地址部分，会留下许多难以利用的、很小的空闲分区，且查找是从头开始，会消耗多余的时间

  2. 循环首次适应算法

     - 定义：对首次适应算法的改进，下次查找是从上一次分配的空间开始
     - 缺点：缺乏大的空闲分区

  3. 最佳适应算法

     - 定义：在所有的空闲分区按其容量有小到大的顺序形成一空闲分区链，在其中找到能满足要求的最小的空间
     - 缺点：每次分配的是所切割下来的剩余部分总是最小的，在存储器中会留下许多难以利用的小空闲区

  4. 最坏适应算法

     - 定义：从顺序空闲分区链中，找最大的空间分配
     - 缺点：虽然可以减少碎片空间，但是缺少大的空闲分区

     以上都是顺序搜索法

     ---

  5. 快速适应算法（分类搜索算法）

     - 定义：将空闲分区根据其容量大小进行分类，对于没一类相同容量的所有空闲分区，单独设立一个空闲分区链表，寻找到能容纳它的最小空间区链表，取第一个
     - 缺点：分区归还主存时算法复杂，系统开销大

- 分区分配操作

  1. 分配内存
  2. 回收内存

##### 伙伴系统

- 定义：在系统运行过程中，由于不断的划分，可能会形成若干个不连续的空闲分区，将这些空闲分区根据分区的大小进行分类，在此基础上进行分配

##### 可重定位分区分配

- 原因：在分区分配过程中会产生许多小空间，我们需要整合这些小空间，就需要移动原有程序

- 实现：动态运行时装入方式，利用硬件地址变换机构，即需在系统中增设一个重定位寄存器，用它来存放程序在内存中的起始地址

- 算法：

  ![](https://ws1.sinaimg.cn/large/a67bf22fgy1fsn820qo2fj20iu0dhdge.jpg)

##### 对换

- 定义：是指把内存中暂时不能运行的进程或者暂时不用的程序和数据调出到处到外存上，以便腾出足够的内存空间，再把已具备运行条件的进程或进程所需要的程序和数据调入到内存
- 对换空间的管理：通常是把外存分为文件区和对换区，文件去使用离散分配方式，对换区使用连续分配方式便于查找

#### 基本分页存储管理方式

- 定义：前面都是连续分配方式，基于分页存储管理方式是离散分配方式
- 基本概念：
  1. 页面
     - 将一个进程的逻辑地址空间分成若干个大小相等的片，称为页面
     - 内存分为与页面相等大小的若干个存储块，称为物理块或者页框
  2. 页面大小
  3. 地址结构：20位页号12位位移量 即每页大小2^12 = 4K 
  4. 页表：记录页面与物理块之间关系的表
- 地址变换机构

#### 基本分段存储管理方式

#### 虚拟存储器

- 定义：仅需将那些当前要运行的少数页面或段先装入内存便可运行，在程序运行时再将没有调入的页面进行调入
- 特征：
  1. 多次性：一个程序被分成多次调用内存
  2. 对换性：作业在运行过程中换入换出
  3. 虚拟性：逻辑上对内存进行扩容

#### 请求分页存储管理方式

- 硬件支持
  1. 页表机制
  2. 缺页中断机构
  3. 地址变换机构

#### 页面置换算法

1. 最佳置换算法：选择的被淘汰页面，将是以后永不使用的，这个是无法实现的
2. 先进先出页面算法
3. LRU置换算法：硬件支持（寄存器或栈）
4. Clock置换算法：根据访问位和修改位来判断置换的页面

#### 请求分段存储管理方式

###  进程管理

#### 进程的基本概念

1. 进程顺序执行的基本特征：顺序性、封闭性、可再现性

2. 进程并发执行的基本特征：间断性、失去封闭性、不可再现性

3. 进程可能会有的所有状态：创建状态、就绪状态、执行状态、阻塞状态、挂起状态、终止状态

4. 进程控制块（PCB）：一种数据结构，用于描述进程的当前情况以及控制进程运行的全部信息，PCB常驻内存。

   其中有主要一下信息：

   1. 进程标识符
   2. 处理机状态
   3. 进程调度信息
   4. 进程控制信息

5. 进程控制块组织方式：

   - 链接方式
   - 索引方式

#### 进程控制

1. 进程的创建
   1. 申请空白PCB
   2. 为新进程分配资源
   3. 初始化PCB
   4. 将PCB插入就绪队列
2. 进程终止
3. 进程的阻塞
   1. 改变PCB中的进程调度信息
   2. 插入阻塞队列
4. 进程唤醒
   1. 改变PCB中的进程调度信息
   2. 插入就绪队列
5. 进程的挂起
6. 进程的激活

#### 进程同步

- 基本概念
  1. 两种形式的制约关系
  2. 临界资源
  3. 临界区
- 信号量机制
  1. 整型信号量
  2. 记录型信息量
  3. AND型信号量
  4. 信号量集
- 管程
  1. 定义：共享资源的数据结构，以及由对该数据结构实施操作的一组过程所组成的资源管理程序，共同构成了一个操作系统的资源管理模块
- 线程
  1. 线程与进程的比较
     - 调度：同一进程的不同线程的切换不切换进程
     - 并发性
     - 拥有资源：访问隶属进程的资源，拥有很少量自己的自己的资源
     - 系统开销：系统开销小
  2. 线程属性：
     1. 轻型实体
     2. 独立调度和分派的基本单位
     3. 可并发执行
     4. 共享进程资源
     5. 线程状态
  3. 线程的实现方式
     1. 内核支持线程
        - 缺点：对于用户线程切换而言，开销很大
     2. 用户级线程
        - 缺点：系统调用阻塞问题；多线程不能利用多处理机进行多重处理
     3. 组合方式
  4. 线程的实现
     - 内核支持线程的实现：就类似于进程了
     - 用户级线程的实现
       1. 运行时系统：用于管理和控制线程的函数集合
       2. 内核控制线程：每个进程拥有多个LWP，一个LWP连接多个用户进程，克服了内核线程的切换线程系统 开销大的问题，也克服了用户线程系统调用阻塞所有其它线程问题

### 处理机调度和死锁

#### 处理机调度层次

1. 高级调度：根据某种算法，把外存上处理后备队列中的那些作业调入内存，调度的对象是作业
2. 低级调度：调度的对象是进程
   - 低级调度的功能：
     1. 保存处理机的现场信息，即进程运行时保存在各种寄存器里面的数据到PCB中
     2. 按某种算法选取下一个运行的进程
     3. 把处理器分配给下一个进程
   - 低级调度的机制：
     1. 排队器：就绪进程队列
     2. 分派器：分派器就是由进程调度程序选定的进程，切换的进程首先把处理机切换到分派进程，然后分派进程再指定下一个进程并切换到下一个进程
     3. 上下文切换机制
   - 进程调度方式
     1. 非抢占式调度：一个进程总是尝试运行完自己所有程序，除非遇到阻塞或异常而退出，再把处理机交给其它进程
     2. 抢占式调度：基于一定的优先原则，当优先级大的进程进入系统，会将当前运行的进程切换到优先级高的进程
3. 中级调度：使那些暂时不能运行的进程调至外存上

#### 调度队列模型和准则

调度队列模型

- 仅有低级调度
- 低级调度和高级调度：从外存的后备队列上选择一个作业，然后封装为一个进程进行运行，进程运行有服从低级调度
- 三级调度都有：前面就像低级和高级调度的形式，然后在进程需要创建子进程内存空间不够的时候，就会换出暂时不会运行的线程到外存，变成外存就绪状态

#### 调度算法的准则

1. 面向用户准则
   - 周期时间短
   - 响应时间快
   - 截止时间保证
   - 优先权准则
2. 面向系统准则
   - 系统吞吐量：就是在一定的时间里能够完成的作业
   - 处理机利用率
   - 资源平衡利用
   - 资源利用平衡

#### 调度算法

1. 高级调度和低级调度都适用的：
   - 先来先服务调度算法：缺点是有利于长作业，不利于短作业；有利于CPU繁忙型作业，因为可以长时间占用处理机，导致其带权周转时间小
   - 短作业调度优先：缺点是不利于长作业
   - 高优先权优先调度算法：抢占式，非抢占式；静态优先权，动态优先权
   - 高响应比优先调度算法：利用动态优先权，进程的优先权随着时间的改变而改变：响应时间/服务时间
2. 低级调度适用的：
   - 时间片轮转调度算法：在给定的时间片内，对按照先来先服务形成的就绪进程队列进程时间片周期轮转执行
   - 多级反馈队列调度算法：设置多个就绪进程就绪队列，队列优先级依次降低，会首先执行优先级高的队列里面的进程且每一个低优先级都是其上一个优先级队列的分配时间片大一倍；创建一个进程时，先放到第一优先级队列，如果第一个时间片没有执行完在放到下一个优先级队列，依次类推；也仅有上一优先级队列为空时下一优先级队列才有机会执行，所以当有第一优先级队列有进程时，在执行第二优先级队列里面的进程时会被抢占
3. 实时调度算法：
   1. 最早截止时间调度算法：有较早截止时间的进程有较高的优先级去执行
   2. 最低松弛度优先：在形成的松弛度有小到大的队列中选取第一个执行，松弛度=必须完成的时间-其本身时间-当前时间

#### 产生死锁的原因和条件

- 产生死锁的原因：
  1. 竞争资源
     - 竞争非剥夺性资源
     - 竞争临时性资源
  2. 进程间推进顺序非法
- 产生死锁的必要条件
  1. 互斥条件
  2. 请求和保持条件
  3. 不剥夺条件
  4. 环路等待条件

### 设备管理

#### IO控制方式

1. 程序IO方式

   ![](https://ws1.sinaimg.cn/large/a67bf22fgy1fsosf465mgj20bt0e574h.jpg)

2. 中断驱动方式

   口述一下就是IO程序发出读命令，然后检测IO设备是否空闲，空闲的话读取一个字到数据寄存器，然后发出中断信号，CPU检查输入过程是否有错，没有错再将字写到内存

   ![](https://ws1.sinaimg.cn/large/a67bf22fgy1fsosnpfw52j20dm0dzgm1.jpg)

3. 直接存储器访问方式(DMA)控制方式

   - 产生的原因：虽然产生了中断驱动IO控制方式，但是我们从上面的流程图可以得知，我们只能节省等待IO设备可用的时间，还有大量的IO传输速度与cpu不匹配所产生的cpu等待IO设备的时间会浪费，DMA方式成百倍的减少了CPU对IO的干预

   - DMA的特点：

     1. 每次传输一个数据块
     2. DMA存在一个缓存区，即内存中的一块地方，所以DMA通过这个缓冲区与CPU进行数据传递，当CPU发送读命令时，从IO设备读取数据到这个缓存区，写命令时CPU右将数据发送到这个缓冲区
     3. 仅在一个数据块操作完成才需CPU干预，取下一个命令

   - 关于设备控制器(DMA)

     - 组成：
       1. DMA与CPU的接口：主要涉及数据线、地址线和控制线，这个三个线与命令/状态寄存器(CR)、内存地址寄存器(MDR)、数据寄存器(DR)、数据计数器(DR)进行数据传递；
       2. DMA与IO设备的接口
       3. IO逻辑：实现对设备控制，通过一组控制线与处理机交互，处理机利用该逻辑向控制器发送IO命令；IO逻辑对收到的命令进行译码

   - DMA工作过程

     ![](https://ws1.sinaimg.cn/large/a67bf22fgy1fsousynm8qj20d70dwdg0.jpg)

4. IO通道控制方式

   - IO通道
     - 定义：是一种特殊的处理机，但是它只能运行IO命令，且与处理机共享内存
     - 产生的原因：DMA只能一次读取一个数据块的数据，IO通道则是DMA方式的发展，可以一次实现多个数据块的传送
     - 执行过程：当CPU要完成一个读操作时，只需向IO通道发送一条IO指令，IO指令包括所要执行通道程序的首址和要访问的IO设备

#### 中断处理程序

- 主要有以下几个步骤
  1. 唤醒被阻塞的驱动进程(这里唤醒的原因是需要中断处理程序处理IO完成后的工作)
  2. 保护被中断进程的CPU环境：我觉得这里需要注意的是与进程进行上下文切换机制不同，后者是将处理机现场信息保存到PCB中，但是这里是吧处理机状态字PSW和程序计数器保存在中断保留区，把被中断进程CPU现场信息压入中断栈中
  3. 转入相应设备处理程序
  4. 中断处理
  5. 恢复被中断进程现场

#### 设备驱动程序

- 定义：他是IO进程与设备控制器之间的通信程序
- 产生原因：由于对不同硬件设备进行IO操作需要不同的指令代码，也即不同的硬件需要不同的驱动程序，所以在我们看来IO程序简单发出一个read或者write命令，但是如果设备控制器直接发给IO设备它是不认识的因为不同的硬件的内部结构是不一样的，所以这个时候就需要设备驱动程序对这个read或者write命令基于不同硬件解析为硬件认识的程序代码然后让设备控制器直接发给IO设备

### 操作系统接口

#### 系统调用

1. 系统态和用户态：在现在的我看来是对处理机两种状态的标志，当处理机是系统态时可以使用所有指令和数据；而用户态只能使用非特权指令，不能使用系统态的空间和数据；这两个状态的切换时通过改变处理机状态字PSW

2. 系统调用实现

   主要是靠中断和陷入机制来完成的；当CPU执行到一条需要系统调用的指令时发生中断并将有关信号送给中断和陷入硬件机构，该机构收到信号后，启动相关的中断和陷入处理程序进行处理