---
title: java并发编程实战读书笔记
date: 2019-03-21 23:52:07
tags: java并发编程实战
---

#### 线程安全性

##### 什么叫线程安全

线程安全核心概念就是正确性，正确性的含义是某个类的行为与其规范完全一致。在良好的规范中通常会定义各种不变性条件来约束对象的状态，以及定义各种后验条件来描述对象操作的结果

##### JAVA 中同步的方式

1. 加锁
2. volatile
3. 原子变量
4. 不可变的类(1. 无状态的类，比如说Servlet；2. 字段全是final 修饰的类)

##### 原子性是怎么保证线程安全的

1. 避免竞态条件
2. 复合操作原子化

##### 用锁进行同步

用锁来保证数据的状态不发生变化，保证数据的一致性；但是加锁有损性能，尽量加锁的粒度

可以利用面向对象的封装性，封装对象的状态，那么对所有该类的方法使用内置锁

####对象的共享

##### 对于共享对象需要注意的问题

1. 共享对象存在可见性问题
2. 由可见性问题可能存在数据失效

##### 解决数据可见性问题

1. 同步加锁的方法，在获得锁和释放锁都能保证数据是最新的
2. volatile，保证读取和修改数据都能够刷新到主存

##### 发布对象的方式

什么是发布对象：就是使对象能够在当前作用域之外的代码中使用

1. 将对象的引用保存到公有的静态变量中

   ```java
   public static Set<Secret> knownSecrets;
   
   public void initialize() {
       knowSecrets = new HashSet<>();
   }
   ```

2. 将私有变量发布

   ```java
   class UnsafeStates{
       private String[] states = new String[]{...};
       
       public String[] getStates(){return states;}
   }
   ```

3. 内部类将this引用发布

   ```java
   public class ThisEscape {
       public ThisEscape(EventSource source) {
           source.registerListener(
           new EventListener() {
               public void onEvent(Event e) {
                   doSomething(e);
               }
           })
       }
   }
   ```

   由于第三种的发布对象的方式，会造成对象在没有初始化完成就将引用发布，会造成不一致问题；所以不再构造函数里面使用内部类，而是用工厂方法去解决

##### 如何保证对象不被发布

1. 栈封闭：由于栈时线程私有的，函数存在于栈里面，所以将对象在函数里面创建，并且不将其返回，那么所有的操作都是线程安全的
2. ThreadLocal

##### 如何安全的共享对象

- 对于不可变对象，JMM对于它的共享提供了特殊的初始化安全性保证(至于这里特殊化安全保证其实就是JMM对final字段重排序的规则)

当然不可变对象需要满足下面的条件：

1. 对象的所有域都是final的
2. 对象时正确创建的即在构造函数中不存在内部类逸出this引用

- 对于可变对象的发布可以用以下方式：
  1. 在静态初始化函数中初始化一个对象的引用（应该是<cinit> 保证不重排序）
  2. 将对象的引用保存到volatile类型的域或者AtomicReference对象中
  3. 将对象的引用保存到某个正确构造对象的final类型域中(final 字段的重排序规则，一个引用的赋值必须在对象构造完毕之后)
  4. 将对象的引用保存到一个由锁保护的域中
  5. 将对象引用放入线程安全的容器里面
- 对于事实不可变对象，只需要安全的发布，后面就可以安全的访问