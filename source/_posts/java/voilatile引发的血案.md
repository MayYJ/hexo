---
title: voilatile引发的血案 
date: 2018-02-25 23:55:41
tags: volatile
categories: java
---

##### java内存模型

每条线程都拥有自己的内存空间，自己内存空间的变量其它线程无法访问；共享的变量是存放在主内存 中的，如果线程要访问，那么就会从主内存中拷贝过来，然后在自己的内存空间中使用。

这有可能引发脏读问题，也就是说当一个线程获取到一个资源后对它进行了修改，但是并没有立即提交到主存，这就造成了其它线程去读取这个资源的时候获取到的资源不是最新的；

问题：初始时，两个线程访问同一个变量i=10，两个线程也都对他们进行了+1操作，这是因为两个线程都取得的i为10所以加1后都为11，所以最终主存中i的值为11；而我们期望的是12；
解决方法：使用java.util.concurrent.atomic包下提供了一些原子操作类对变量进行操作，这样这个变量对的取值和赋值为一个原子性的操作不会被打断，那么不管另外一个线程什么时候读取i变量都能够保证为一个最新的值，即能保证i最终为12

##### 并发编程的三大概念

- 原子性

  1. 定义：一个操作或者多个操作要么全部执行并且执行过程中不能够被打断，要么都不执行。
  2. java中的原子性：对基本类型的读取和赋值是原子性的
     x=10;
     y=x;
     x++;
     x=x+1;
     其中只有第一句话是原子性的操作；第一句话是直接将数值10写入到线程的内存当中；第二句话是先去读取x的值，然后再讲值写入y代表的内存当中；第三句话差不多也是先读取x的值然后进行+1操作；第四句话和第三句话一样。
  3. voilatile不能保证变量+-的原子性，可以使用java.util.concurrent.atomic包下提供了一些原子操作类

- 可见性

  1. 定义：可见性是当多个线程访问同一个变量的时候，一个线程修改了这个歌变量的值，其他线程能够立即看得到修改的值。

  2. java中的可见性
     对于可见性java提供了volatile关键字来保证可见性。
     当一个共享变量被volatile修饰时，它会保证修改的值立即被更新到主存，当有其它线程需要读取值时也都会到主存中读取；而普通的共享变量被修改过后什么时候写入到主存是不确定的；

     - 有序性

     1. 定义：即程序执行的顺序按照代码的先后顺序执行；

        ​

        给一个例子

        ```
        context = loadContext; //语句1

        inited = true; //语句2

        //线程2:

        while(!inited ){

        sleep

        }

        doSomethingwithconfig(context);

        ```

  上面的代码中由于语句1和语句2没有数据依赖，因此可能会重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。

  ​               

- java的有序性

  在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。

```
在Java里面，可以通过volatile关键字来保证一定的“有序性”。即volatile变量的语句不会与它前面或者后面的语句进行重排序，但是不能保证它前面或者后面的语句之间不会重排序。
   happens-before原则：

- 程序次序规则：：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作
  注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，但是虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。
- 锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作
  也就是说无论在单线程中还是多线程中，同一个锁如果处于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。
- volatile变量规则
  直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。
- 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C
- 线程启动规则
- 线程中断规则
- 线程终结规则
- 对象终结规则

```